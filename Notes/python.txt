python

/Users/smukherjee/IdeaProjects/untitled2

name=input("Please enter name")

print() - no distinction between '..' & ".." , whatever we start with the lone should end with it.Placing a \ infront of " or ' in the middle willescape it.

splitstring = """ this string has 
many lines, no need for a backslash """

# both program & variables get stored somewhere in memory.When we use a variable - computer allocates a computer memory & stores value there,computer know reference to the place

## python variable names are case sensitive, implicit casting of variable to other type is not supported.

Data types:
Numeric
Sequence 


print(a / b) - returns result in float
print(a // b) - returns result in integer
print(a % b) - return the remainder

operator precedence:
() , /, * with highest precedence.

String - Immutable - Sequence type - 0 based index, -ve index starts counting from end
Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points.

Editing string at positional index is not possible.We can only reassign the value


parrot="Norwegian Blue"
parrot[0:6] -> will give a range from string Norweg
parrot[:6] -> automatically starts at 0 index
parrot[6:] -> starting from 6th position ,go till end
parrot[-4:2] -> WILL NOT PRINT ANYTHING ( either mention with -ve or +ve in both)
parrot[-4:-2] -> start from 4th(back side start with -1) position from last & for 2 place
parrot[0:6:2] -> from 0 till 6 position, every 2nd letter

number = "9,123,234,345,456"
print(number[1::4]) -> extract only commas starting from 1(2nd letter),every 4th char

numbers="1, 2, 3, 4, 5, 6, 7, 8"
print(numbers[0::3]) -> extract only numbers

substring check => print("day" in "friday")

# Replacement field - python3 new feature

print("""January: {2}
February: {0}
March: {2}
April: {1}
May: {2}
June: {1}
July: {2}
August: {2}
September: {1}
October: {2}
November: {1}
December: {2}""".format(28, 30, 31))


age = 24
print("My age is %d %s, %d %s" % (age, "years", 6, "months"))

for i in range(1, 12):
    print("No. %2d squared is %4d and cubed is %4d" %(i, i ** 2, i ** 3))

print("Pi is approximately %12f" % (22 / 7))

for i in range(1, 12):
    print("No. {0:2} squared is {1:4} and cubed is {2:4}".format(i, i ** 2, i ** 3))

for i in range(1, 12): #Related to left/right associativity 
    print("No. {0:2} squared is {1:<4} and cubed is {2:<4}".format(i, i ** 2, i ** 3))

print("Pi is approximately {0:12.50f}".format(22 / 7))
print("Pi is approximately {0:52.50f}".format(22 / 7))

for i in range(1, 12):
    print("No. {} squared is {} and cubed is {:4}".format(i, i ** 2, i ** 3))

# ===================================================

in a condition any non zero or non-Empty value evaluates to true



name=input("Please enter name: ")
age=int(input("What's your age {0} ?\n".format(name)))

if (18 <= age < 31 ):
    print("Welcome {0} to 18-30 holiday".format(name))
else:
    print("Sorry,you can't enter")   

# =====================================================   
Range fn does not include last value - range(1,20) will include values from 1 to 19  

number = "9,123,234,345,456"
cleaned_number=''
for i in range(0,len(number)):
    if number[i] in "123456789":
       cleaned_number=cleaned_number + number[i]
       #print(number[i],end='')

new_number=int(cleaned_number)
print("The new number is : {}".format(new_number))    

# ---

python for loop can operate on "sequence" type.

quote = """
Alright, but apart from the Sanitation, the Medicine, Education, Wine,
Public Order, Irrigation, Roads, the Fresh-Water System,
and Public Health, what have the Romans ever done for us?
"""
only_caps=''

for i in quote:
    if i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
       print(i,end='')

for i in range(0,100,7):
    print(i)

# ---- Multiplication table:
                                                        
for i in range(1,21):                                   
    for j in range(1,21):                               
        print("{1} * {2:>2} = {0:>4}".format((i*j),i,j))
print("\n")                                                   
# =====================================================

# for loop has an else section available which gets executed if loop till end value is allowed to run without any "break" in between.

food=["milk", "bread", "beans", "tomato"]
nasty_food=''
for i in food:
    if i == "spam":
       nasty_food = 'spam' 
       break
else:
    print("I will have 1 plate then")

if nasty_food == 'spam':
   print("cant's I have anything without spam") 
# =====================================================

for i in range(0, 100, 7):
    if (i>0) and (i%11 == 0):
        print(i)
        break
    else:
        print(i)
else:
    print("no such no found")

for i in range(0,20):
    if (i%3 == 0) or (i%5 == 0):
        continue
    else:   
        print(i)  

for i in range(0,20):
    if (i%3 != 0) or (i%5 != 0)):  
        print(i) 

# -------------

Augmented assignment:

# += -= *= /= %= **= <<= >>= &= ^= |=

number = 5
multiplier = 8
answer = 0

i=1
for i in range(multiplier):
    answer+=number

print("Answer is : {}".format(answer))

# -----IP address - no of segment & length of segment-------------
123.78.0.1
3 2 1 1

ip=input("enter ip address")
if ip[-1] !='.'
    ip+='.'


t=0
s=1 #no of segment


for c in ip:
    if c=='.':
        print("segment no {0} has {1} chars ".format(s,t))
        s+=1
        t=0
    else:
        t+=1

for x in range(30):
    if x % 3 == 0 or x % 5 == 0:
        continue
    print(x)

for x in range(30):
    if x % 3 != 0 and x % 5 != 0:
        print(x)



 # -------------
# Guessing number game:

import random

max_value=20
selected_number = random.randint(1,max_value)
print("Please enter number within 1 to {}".format(max_value))

t=0
while t<3:
    user_input_number=int(input("enter number:")) 
    if user_input_number==selected_number:
        print("You guessed correctly.")
        break
    elif user_input_number==0:
        print("Quiting program")
        break 
    else:
        t+=1 
        if (user_input_number < selected_number) and (t<3):
            print("guess higher")
        if (user_input_number < selected_number) and (t<3):
            print("guess lower") 
                       
else:
    print("GAME OVER: The number was : {}".format(selected_number))

# -----------
Sequence Data types - List Range Tuple :
-----------------------------------------

sort() method works on existing variable ,does not create a new object.
sorted() method returns a new objects in sorted order without changing order of original object.

>>> l=[2,1,3]
>>> l.sort()
>>> l
[1, 2, 3]
>>> l1=[3,1,2]
>>> l2=sorted(l1)
>>> l2
[1, 2, 3]
>>> l1
[3, 1, 2]
>>>

List_1=[] #empty list same as List_2=list()

##New concept: 
even=[2,4,6,8]
another_even=even # assignment like this does not create a new variable in python,it just references to same object in memory
a call like another_evn.sorted(reverse=True) will reverse the original list in descending order.
another_even=list(even) will create a new object in memory,then call like another_evn.sorted(reverse=True) will not 
alter original content of even list.

"=="  tests for element equality in python - whether two lists have same elements
"is" checks for object equality - if two objects are same/same memory loc being referenced.
with,
another_even=list(even)

another_list == even -> will be true
another_list is even -> will be false


menu=list()
menu.append(['egg','spam','bread'])
menu.append(['egg','orange'])
menu.append(['egg','apple','spam'])

for meal in menu:
    if not "spam" in meal:
        print(meal)
        for i in meal:
            print(i)


Iterators & Iterable objects:
------------------------------
Iterators is an object that represent a stream of data.  

String,List

Iterators are created like below:
my_iter = iter(string)
next(my_iter) - returns the next item from iterator ,untill "StopIteration" error is received.

menu2=['egg','spam','bread']
iter_menu2=iter(menu2)

for i in range(menu2.__len__()):
    print(next(iter_menu2))

# Range
--------
in Python3 Range is an object.

my_list=list(range(0,10)) -> creating a list from range
even=list(range(0,10,2))
odd=list(range(1,10,2))

print(odd[985]) -> will return 986th value from range.

Also we can check if a no is within a range:

rangle_val =range(7,10000,7)
inp =int(input("please enter number"))

if inp in rangle_val:
    print("{} is divisible by 7".format(inp))
else:
    print("{} is NOT divisible by 7".format(inp)) 

### Sliced range:
We can slice a range part of another bigger range

decimals=range(0,1000)

my_range=decimals[3,50,3] --> we are taking values from 3 to 50 using decimals range


SLI,SLO

r=range(0,100,2)
r[::2] sliced out from last value and decrease it one by one

processing range in reverse order r[::-1] , applicable to string as well
>>> pr=range(0,55,3)
>>> pr1=pr[::4]
>>> print(pr1)
range(0, 57, 12)
>>> for i in pr1:
...     print(i)
...
0
12
24
36
48

how is 57 :  max value within range with old base + old base value
eg: pr=range(0,55,3) -> 54 is max val + 3 base value

with -1 indicator - smallest value(start value) with old base - mod(old base value)

Tuples:
a heterogeneous sequence of elements - immutable
Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). 
Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.

we can slice out tuple using index:
t=('a','b','c')
t[1] will be=b
t2=(t[0],'new value',t[2])

We can extract multiple parts of a tuple in single line of variables.



imelda = "More Mayham","Imelda May",2011,(
       (1,"Putting the rug"), (2,"Psycho"), (3,"Mayhem"), (4,"Kentish Town Waltz"))

title,singer,year,tracks=imelda

print(title)
print(singer)
print(year)

for song in tracks:
    tr_no,song=song
    print("\ttrack no: {0} song: {1}".format(tr_no,song))

### Teaser: A tuple is immutable, it's contents can't be changed but if a tuple has one element as List , List is mutatble and values can be added to that list   


imelda = "More Mayham","Imelda May",2011,(
       [(1,"Putting the rug"), (2,"Psycho"), (3,"Mayhem"), (4,"Kentish Town Waltz")])

# [] -> 4th element is a list now instead of tuple
# 1 tuple containing 1 list is same as the list
print(imelda)

imelda[3][0].append((5,"All For You"))

print(imelda)
title,singer,year,tracks=imelda

tracks.append((6,"Eternity"))

print(title)
print(singer)
print(year)

for song in tracks:
    tr_no,song=song
    print("\ttrack no: {0} song: {1}".format(tr_no,song)) 


# How to decide if a variable is mutable or immutable?

Take help of id() function which returns the memory location of the object
The unique identifier is pointing to a location in memory, which is an object. 

>>> a = 1
>>> b = 2
>>> c = 2
>>> c
2
>>> id(c)
10105120
>>> id(c)
10105120
>>> id(b)
10105120

The object, 10105120, is the unique identifier. It’s the location in memory. Objects can have multiple variables

>>> my_list = ['cat', 'dog', 'bunny']
>>> my_list
['cat', 'dog', 'bunny']
>>> print('Address of my_list is: {}'.format(id(my_list)))
Address of my_list is: 139929780579208

If we want to change the first value in our list and print it out, we can see that the list changed, but the memory address of the list is the same. It changed the value in place. That’s what mutable means.

>>> my_list[0] = 'sugar glider'
>>> my_list
['sugar glider', 'dog', 'bunny']
>>> print('Address of my_list is: {}'.format(id(my_list)))
Address of my_list is: 139929780579208
>>> my_list
['sugar glider', 'dog, 'bunny']
>>> id(my_list)
139929780579208
>>> my_list[0]
'sugar glider'
>>> id(my_list[0])
139905997708792
>>> my_list[0] = 'rabbit'
>>> id(my_list[0])
139905997708400
>>> id(my_list)
139929780579208

----------------------------
# Binary Number System:
---------------------------- 


-----------------
#   Dict & Set
-----------------
Dict & Set both are unordered collection, they also gurantees that there will not be any duplicates.
No access by index.

Performing list(d) on a dictionary returns a list of all the keys used in the dictionary, 
in insertion order (if you want it sorted, just use sorted(d) instead)

fruit={"apple":"A for apple","orange":"O for orange" ,"lemon":"l for lemon"}
print(fruit["apple"])
fruit["apple"] is same as fruit.get("apple")
fruit.get("apple","We doe not have the fruit") -> if item does not exist then returns None type.

fruit["bananna"]="B for bananna" --> adds/overwrites item to dict

del fruit["bananna"] removes item
del fruit -> removes entire dict
fruit.clear() -> empties the dict but keeps the dict


fruit.keys() /fruit.values() -> returns the keys & values in form of a view object.
fruit.items() -> returns the k-v pair in a list of tuples like view objects

# dict -> tuple
----------------
using below we can convert them to tuple.
f_tuple=tuple(fruit.items()) 

# tuple -> dict
----------------
dict(f_tuple)

# join & split()
-----------------

# .join() method for list/String - a good method add seperator between string /list
eg.
mylist=["a","b","c","d"]
",".join(mylist) -> a,b,c,d
        
# any sequencse.split(',')

# update & copy method
update - combine two dicts together - alters original dict
copy -creates anew copy
>>> a={1:'a',2:'b',3:'cc'}
>>> b={3:'c',4:'d'}
>>> a.update(b)
>>> print(a)
{1: 'a', 2: 'b', 3: 'c', 4: 'd'}
>>> c=a.copy()
>>> print(c)
{1: 'a', 2: 'b', 3: 'c', 4: 'd'}
>>>

Direction Game:
------------------------------
# Challenge time!
# We have mentioned that the data for the Adventure game could be organised in many
# different ways.  We've created another way for you.
# Your mission, if you choose to accept it, is to
# change the code to make it work.
# Below is the the complete program from the last video, but with the
# locations dictionary modified so that everything is in a single dictionary.
# N.B. Yes the code has some errors, thats what you need to fix!

locations = {0: {"desc": "You are sitting in front of a computer learning Python",
                 "exits": {},
                 "namedExits": {}},
             1: {"desc": "You are standing at the end of a road before a small brick building",
                 "exits": {"W": 2, "E": 3, "N": 5, "S": 4, "Q": 0},
                 "namedExits": {"2": 2, "3": 3, "5": 5, "4": 4}},
             2: {"desc": "You are at the top of a hill",
                 "exits": {"N": 5, "Q": 0},
                 "namedExits": {"5": 5}},
             3: {"desc": "You are inside a building, a well house for a small stream",
                 "exits": {"W": 1, "Q": 0},
                 "namedExits": {"1": 1}},
             4: {"desc": "You are in a valley beside a stream",
                 "exits": {"N": 1, "W": 2, "Q": 0},
                 "namedExits": {"1": 1, "2": 2}},
             5: {"desc": "You are in the forest",
                 "exits": {"W": 2, "S": 1, "Q": 0},
                 "namedExits": {"2": 2, "1": 1}}
             }

vocabulary = {"QUIT": "Q",
              "NORTH": "N",
              "SOUTH": "S",
              "EAST": "E",
              "WEST": "W",
              "ROAD": "1",
              "HILL": "2",
              "BUILDING": "3",
              "VALLEY": "4",
              "FOREST": "5"}

loc = 1
while True:

    availableExits = ", ".join(locations[loc]["exits"].keys())

    print(locations[loc]["desc"])

    if loc == 0:
        break
    else:
#        allExits = exits[loc].copy()
         allExits =locations[loc]["exits"].copy()
         allExits.update(locations[loc]["namedExits"])

    direction = input("Available exits are " + availableExits).upper()
    print()

    # Parse the user input, using our vocabulary dictionary if necessary
    if len(direction) > 1:  # more than 1 letter, so check vocab
        words = direction.split()
        for word in words:
            if word in vocabulary:   # does it contain a word we know?
                direction = vocabulary[word]
                break

    if direction in allExits:
        loc = allExits[direction]
    else:
        print("You cannot go in that direction")

# Sets
----------
unordered-no index based access -immutable -can be defined with {}
most cases we use set() -constructor method
add(),union(),intersect(),difference()
symmetric_difference() - items from both set which are not common in both set,

# String,Tuple,Set,Range are immutable
# List,Dict are mutable


difference_update,discard vs remove,issubset(),isuperset()
discard vs remove - removal of 2nd time throws error,if item is not there

frozenset - immutable set - can be used as keys 


testString="This is MAX"
testSet=set(testString)
vowelSet={'a','e','i','o','u','A','E','I','O','U'}
conjunctionSet={' ','.',';'}

finalSet=(testSet.difference(vowelSet)).difference(conjunctionSet)
print("All the consonants in text are: {}".format(finalSet))
print("All the consonants in text are: {}".format(finalSet))    

--------------------------
Input & Output in Python
--------------------------

with statement automatically takes care of file closing & cleanup if some inbetween op fails while the file was open.

read() -returns entire content as a single string
readLines() -returns entire content as a list of strings.
readline() - read 1 single line & returns as a string-can be used in while loop for iteration

#
# with open("sample.txt", 'r') as jabber:
#     line = jabber.readline()
#     while line:
#         print(line, end='')
#         line = jabber.readline()

# with open("sample.txt", 'r') as jabber:
#     lines = jabber.readlines()
# print(lines)
#
# for line in lines:
#     print(line, end='')
#

with open("sample.txt", 'r') as jabber:
    lines = jabber.readlines()
print(lines)

for line in lines[::-1]:
    print(line, end='')

with open("sample.txt", 'r') as jabber:
    lines = jabber.read()

for line in lines[::-1]:
    print(line, end='')

write to file:
with statement in 'w' mode , mention print(variable_name,file=filname.txt)
for writing to file.
strip() function on a strip removes chars from beginning or end of string.
program writes --> buffer --> file for large read,in the mean time program will work on other tasks.fo large files it's good to flush immediately, using flush=True.not recommended now a days.

eval() function to evaluate while reading from a file, will automatiicaly take care of target data type


with open("/Users/smukherjee/sample.txt",'a') as sample_txt_file:
    for i in range(2,13):
        for j in range(1,13):
            print("{0:2} times {1:2} is {2:3}".format(j,i,i*j),file=sample_txt_file)
        print("-"*40,file=sample_txt_file)    
    print("-- END --",file=sample_txt_file)        

case - Binary files:
Integers & Strings can NOT be written to binary file directly,must be converted to Bytes first.

Pickle & Shelve to work with Binary Data: 
-------------------------------------------
import pickle
import shelve


Pickle:
The pickle module implements binary protocols for serializing and de-serializing a Python object structure. “Pickling” is the process whereby a Python object hierarchy is converted into a byte stream, and “unpickling” is the inverse operation, whereby a byte stream (from a binary file or bytes-like object) is converted back into an object hierarchy. Pickling (and unpickling) is alternatively known as “serialization”, “marshalling,” 1 or “flattening”; however, to avoid confusion, the terms used here are “pickling” and “unpickling”.
It is used for storing & restoring.
# Objects must be read in same order they way they were pickled.

import pickle

even=list(range(0,10,2))
odd=list(range(1,10,2))

with open("sample.pickle",'wb') as sample_pickle_file:
    pickle.dump(even,sample_pickle_file)
    pickle.dump(odd,sample_pickle_file)
    print("write completed")

with open("sample.pickle",'rb') as sample_file:
    even_list=pickle.load(sample_file)
    odd_list=pickle.load(sample_file)
    
print("even list content : {}".format(even_list))
print("odd list content : {}".format(odd_list))

Shelve:
Pickled objects requires all to be loaded back to memory, but may not support always - Shelves works like a persistent dict stored in file
in form of shilve_name.db.Key-Value pair storage. But Keys are stored as Strings.when changed ,both correct & 
incorrect key will still be stored in db file.

dict vs shelves - dict key can be any immutable object but shelves key must be a string

import shelve

#with shelve.open('ShelfTest') as fruit:
 
fruit = shelve.open('ShelfTest')
fruit['orange'] = "a sweet, orange, citrus fruit"
fruit['apple'] = "good for making cider"
fruit['lemon'] = "a sour, yellow citrus fruit"
fruit['grape'] = "a small, sweet fruit growing in bunches"
fruit['lime'] = "a sour, green citrus fruit"

print(fruit["lemon"])
print(fruit["grape"])

for k in fruit.keys():
    print("Key: {0} and value : {1}".format(k,fruit[k]))
 
for v in fruit.values():
    print("Values: {}".format(v))

for i in fruit.items():
    print("item: {}".format(i))        
    t_key,t_val=i
    print("t_key: {}".format(t_key))
    print("t_val: {}".format(t_val))


l_keys_list=list(fruit.keys())
l_keys_list.sort()
for i in l_keys_list:
    print("orders list: {}".format(i))

fruit.close()

Updating with Shelves:
appending  to a list is actually copying the list into memory and adding an item to the list in memory.But there is now way write back
that data to the shelve.But when accessd it is read from the original shelve data with unchanged value.Here we need to create a temp_list with the exiting values .Add a value to the temp_list.
Alternative 
is opening shelve with writeback flag=true

with shelve.open("recipes",writeback=True):
     recipes["soup"].append("croutons")

generally with writeback option ,entries will be written to disk when shelve finally closed.to avoid that we can use sync in between to write the data immediately and clear memory cache.
recipes.sync()

# ------------------------------------

# Modify the program from the Second Dictionary challenge of lecture 56
# to use shelves instead of dictionaries.
#
# Do this by creating two programs. cave_initialise.py should create the two
# shelves (locations and vocabulary) with the appropriate keys and values.
#
# cave_game.py will then use the two shelves instead of dictionaries.
# Apart from opening and closing the shelves, cave_game will need only
# two changes to the actual code - remember that shelf keys MUST be strings!
#
# Just to be clear, cave_game.py will contain the code from line 45, everything
# before that (modified to use shelves) will be in cave_initialise.py.


import shelve

locations=shelve.open("locations",writeback=True)
vocabulary=shelve.open("vocabulary",writeback=True)

locations["desc"] = {0: "You are sitting in front of a computer learning Python",
                     1:"You are standing at the end of a road before a small brick building",
                     2:"You are at the top of a hill",
                     3:"You are inside a building, a well house for a small stream",
                     4:"You are in a valley beside a stream",
                     5:"You are in the forest"                     
                     }


locations["exits"]= {0:{},
                     1:{"W": 2, "E": 3, "N": 5, "S": 4, "Q": 0},
                     2:{"N": 5, "Q": 0},
                     3:{"W": 1, "Q": 0},
                     4:{"N": 1, "W": 2, "Q": 0},
                     5:{"W": 2, "S": 1, "Q": 0}
                     }
locations["namedExits"]={0:{},
                         1:{"2": 2, "3": 3, "5": 5, "4": 4},
                         2:{"5": 5},
                         3:{"1": 1},
                         4:{"1": 1, "2": 2},
                         5:{"2": 2, "1": 1}
                         }

vocabulary["QUIT"]="Q"
vocabulary["NORTH"]="N"
vocabulary["SOUTH"]="S"
vocabulary["EAST"]="E"
vocabulary["WEST"]="W"
vocabulary["ROAD"]="1"
vocabulary["HILL"]="2"
vocabulary["BUILDING"]="3"
vocabulary["VALLEY"]="4"
vocabulary["FOREST"]="5"


locations.close()
vocabulary.close()

---------------


import shelve

locations=shelve.open("locations")
vocabulary=shelve.open("vocabulary")


loc = 1
while True:
    #availableExits = ", ".join(locations[loc]["exits"].keys())
    availableExits = ", ".join(locations["exits"][loc].keys())

    print(locations["desc"][loc])

    if loc == 0:
        break
    else:
        allExits = locations["exits"][loc].copy()
        allExits.update(locations["namedExits"][loc])

    direction = input("Available exits are " + availableExits).upper()
    print()

    # Parse the user input, using our vocabulary dictionary if necessary
    if len(direction) > 1:  # more than 1 letter, so check vocab
        words = direction.split()
        for word in words:
            if word in vocabulary:   # does it contain a word we know?
                direction = vocabulary[word]
                break

    if direction in allExits:
        loc = allExits[direction]
    else:
        print("You cannot go in that direction")

locations.close()
vocabulary.close()

------------------

Modules & Functions:


import time
perf_counter - measurments
monotonic - not affected by daylight save changes
procss_time -cpu time

import time

print("local time value:{}".format(time.localtime()))
start_time =time.time()


print("------------challenge---------------")
print("time clock info: {}".format(time.get_clock_info('clock')))
print("time time.time() info: {}".format(time.get_clock_info('time')))
print("time time.monotonic info: {}".format(time.get_clock_info('monotonic')))
print("time perf_counter info: {}".format(time.get_clock_info('perf_counter')))


end_time =time.time()
print("Started at " + time.strftime("%X", time.localtime(start_time)))
print("Ended at " + time.strftime("%X", time.localtime(end_time)))
print("Total run time".format(end_time - start_time))


dealing with Date rather than time- better to use: datetime module




tkinter - GUI based module:
pack
grid


Functions:
------------------

all functions should return something ,else it will return None.

varargs,named parameters,default values for parameters.

OOP - deviding functionalities in different code segements for reuse
Class: - blueprint with attribute & methods - template for creating objects. All objects created using the same class will have the same characteristics.
class deff is loaded into memory
Object: an instance of a class.
Instantiate: create an instance of a class.
Method: a function defined in a class.
Instance Attribute: a variable bound to an instance of a class.

class attribute - attribute shared by all instances
class attribute can be overwritten in instance level,
also python allows additional attribute at instance level.

@classmethod & @staticmethod -
----------------------------------
class methods are similar to class attribute, they can be used without instancing a class object.
they can be called by using class name.

@classmethod
def add(cls,num1,num2): # cls here denote the class name - like self
    return num1 + num2
can be called classname.add(4,3)
classmethods can be used to retun object as well.

def add(cls,num1,num2):
    return cls("new_vale", num1 + num2)

@staticmethods are used when the functioanlities does not depend on class state ie self.param1,self.param2 etc.
it is different from classmthod, as classmethod has access to "cls" value ie the classname.
Intellij detects that function is not using self parameter, so it can be implemented as a static method 
(ie whose return value does not depend on input parameters being passed.)

Static method is shared by all instances of a class
1. remove self parameter
2. put annotation @staticmethod at the top of method name
3. static method should be  called by using class name,not by instance name or self inside class.

-----------------------------------
4 -pillars of OOP

Encapsulation - binding of data & functions that works on that data.We encapsulate (data & func) inside an object

Abstraction - abstraction means hiding of information/abstracting away information and giving access to only what's necessary for program/user
              not interested to understand implementation of the functionality

Inheritance - Inheritance allows objects to take properties of existing objects, we can inherite classes.

Polymorphism - [Poly (many) + morph(form)]
- polymorphism(many-form)[Wizard-fn attack(),Archer-fn attck()] ==> call_attack_fn(player){player.attck()} 
if we pass wizard ob, the one result & archer obj the diff result, so called polymorphism


private vs pulic variable:(under Abstraction concept)
-----------------------------------
No concept/keyword like private in python, though usual convension is use _ infront eg. _name
Though it can be still overwritten , but bad practice.


Inheritance in Python
--------------------------

Inheritance is the capability of one class to inherit the properties from another class.
class Person( object ):    
  
        # __init__ is known as the constructor         
        def __init__(self, name, idnumber):   
                self.name = name
                self.idnumber = idnumber
        def display(self):
                print(self.name)
                print(self.idnumber)
  
# child class
class Employee( Person ):           
        def __init__(self, name, idnumber, salary, post):
                self.salary = salary
                self.post = post
  
                # invoking the __init__ of the parent class 
                Person.__init__(self, name, idnumber) 
  
                  
# creation of an object variable or an instance
a = Employee('Rahul', 886012, 200000, "Intern")

Different forms of Inheritance: 
1. Single inheritance
2. Multiple inheritance: When a child class inherits from multiple parent classes.We specify all parent classes as a comma-separated list in the bracket. 
class Base1(object):
    def __init__(self):
        self.str1 = "Geek1"
        print("Base1")
  
class Base2(object):
    def __init__(self):
        self.str2 = "Geek2"        
        print("Base2")
  
class Derived(Base1, Base2):
    def __init__(self):
          
        # Calling constructors of Base1
        # and Base2 classes
        Base1.__init__(self)
        Base2.__init__(self)
        print("Derived")
          
    def printStrs(self):
        print(self.str1, self.str2)
ob = Derived()
ob.printStrs()

3. Multilevel inheritance: When we have a child and grandchild relationship.
class Base(object):
      
    # Constructor
    def __init__(self, name):
        self.name = name
  
    # To get name
    def getName(self):
        return self.name
  
  
# Inherited or Sub class (Note Person in bracket)
class Child(Base):
      
    # Constructor
    def __init__(self, name, age):
        Base.__init__(self, name)
        self.age = age
  
    # To get name
    def getAge(self):
        return self.age
  
# Inherited or Sub class (Note Person in bracket)
class GrandChild(Child):
      
    # Constructor
    def __init__(self, name, age, address):
        Child.__init__(self, name, age)
        self.address = address
  
    # To get address
    def getAddress(self):
        return self.address        
  
# Driver code
g = GrandChild("Geek1", 23, "Noida")  
print(g.getName(), g.getAge(), g.getAddress())

Private members of parent class :

We don’t always want the instance variables of the parent class to be inherited by the child class 
i.e. we can make some of the instance variables of the parent class private, which won’t be available to the child class. 
We can make an instance variable by adding double underscores before its name. For example,
class C(object):
       def __init__(self):
              self.c = 21
  
              # d is private instance variable 
              self.__d = 42    #Name mangling- _Classname__variable, _C__d is the variable name
class D(C):
       def __init__(self):
              self.e = 84
              C.__init__(self)
object1 = D()
  
# produces an error as d is private instance variable
print(object1.d)


print("Models: {0.make} = {0.price}, {1.make} = {1.price}".format(kenwood, hamilton))

print(Kettle.__dict__)
print(kenwood.__dict__)
print(hamilton.__dict__)

Name mangling:(done for simulating private access to variable)

if we start any variablename with two (_) inside class
eg. __balance ==> python automatically converts it to _Classname__variable.
this way attribute is hidden from outside.

---------------------------------------------------------------
## Abstract Base Classes in Python:
---------------------------------------------------------------


The Employee class in the example above is what is called an abstract base class. Abstract base classes exist to be inherited, but never instantiated. Python provides the abc module to define abstract base classes.

You can use leading underscores in your class name to communicate that objects of that class should not be created. Underscores provide a friendly way to prevent misuse of your code, but they don’t prevent eager users from creating instances of that class.

The abc module in the Python standard library provides functionality to prevent creating objects from abstract base classes.

You can modify the implementation of the Employee class to ensure that it can’t be instantiated:

# In hr.py

from abc import ABC, abstractmethod

class Employee(ABC):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    @abstractmethod
    def calculate_payroll(self):
        pass

You derive Employee from ABC, making it an abstract base class. Then, you decorate the .calculate_payroll() method with the @abstractmethod decorator.

This change has two nice side-effects:

1. # You’re telling users of the module that objects of type Employee can’t be created.
2. # You’re telling other developers working on the hr module that if they derive from Employee, then they must override the .calculate_payroll() abstract method.

You can see that objects of type Employee can’t be created using the interactive interpreter:


Composition:
---------------------

Composition is a concept that models a 'has a' relationship. It enables creating complex types by combining objects of other types. This means that a class Composite can contain an object of another class Component.

For example, your Horse class can be composed by another object of type Tail. Composition allows you to express that relationship by saying a Horse has a Tail.


https://realpython.com/inheritance-composition-python/ (VERY IMPORTANT)
https://towardsdatascience.com/mastering-class-inheritance-in-python-d286eb480e9c

super() method - https://realpython.com/python-super/
Method resolution order: classname.__mro__

Class level circular reference: Garbage collection:
----------------------------------------------------
https://www.geeksforgeeks.org/garbage-collection-python/
https://www.tutorialspoint.com/How-does-garbage-collection-work-in-Python

def __del__(self):
      class_name = self.__class__.__name__       
      print class_name, "destroyed"

Invoking the garbage collector manually during the execution of a program can be a good idea on how to handle memory being consumed by reference cycles. 
import gc
i = 0
 
# create a cycle and on each iteration x as a dictionary
# assigned to 1
def create_cycle():
    x = { }
    x[i+1] = x
    print x
 
# lists are cleared whenever a full collection or
# collection of the highest generation (2) is run
collected = gc.collect() # or gc.collect(2)
print "Garbage collector: collected %d objects." % (collected)
 
print "Creating cycles..."
for i in range(10):
    create_cycle()
 
collected = gc.collect()
 
print "Garbage collector: collected %d objects." % (collected)



# dunder method - methods supplied via Object class by default
eg, __len__, __init__, __repr__, __str__


-----------

Getter & Setter:

1. method which is used to get data attribute value without a direct access to variable.


how it is used?

property() -> getter/setter method --> hidden data attribute

# When we try to print an object it tries to look for a method called __str__ which should return a string format value


@property -> def getter
@score.setter -> for setter

practice - vd -137

python is dynamically typed language.not like java which is static typed language.in java duirng compile data type of 
every variable is checked.But in python it is checked only when it is being used.
OOP program:


Polymorphism implementation using Composition:
Polymorphism implementation using aggregation:


Exception:

Error handling:
try
except
else - when try block execution is complete without throwing any exception
finally - always executed - with continue or break as well


raise Exception/TypeError or any other type - a user generated exception



differnce between else & finally. (else part if,while,try block behave differently)
else part is executed if try block executes as expected without any exception thrown, finally part is executed always

# Explicit data type reference: (a: str) -> int (vd-177 Learn Python Programming Masterclass)
isinstance() function
callable() function - whether on an object, a function can be called without throwing exception: used for adding problematics file to a list & pulish at the end
get_attr() functions are used to see if an object's type.

# How to store a complete object in database column using python:
use pickle to store, store picked value



# rollback trasacttions:
vd -188

# *args & **kwargs
----------------
multi values being passed to function will be collected as a tuple, which can be used inside function.
kwargs - key with arguments - values are collected as a dict.
args are used to unpack elements in tuple, kwargs are used to unpack values in a dict


#Python dates: https://janakiev.com/blog/time-and-timezones-in-python/

# how to store UTC time & local time?
vd -187

How to localise UTC time?
transaction_local_time = datetime.datetime.now()
datetime_tz_name = pytz.timezone('Asia/Calcutta').localize(transaction_time)

How to get current time zone info?
>>> import datetime
>>> tz_string = datetime.datetime.now(datetime.timezone.utc).astimezone().tzname()
>>> print(tz_string)
IST


# section-12 : Generators, Decorators,lambda
----------------------------------
Generators are a simple and powerful tool for creating iterators. 
They are written like regular functions but use the yield statement whenever they want to return data.
 Each time __next__() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed)

Generators are implemented using keyword - yield - they give one o/p & goes to a pause step, does not exit or gets 
finished.

Generator in python is a subclass of Iterator. To prove this, we use the issubclass() function.

>>> import collections,types
>>> issubclass(types.GeneratorType,collections.Iterator)

True


# A simple generator for Fibonacci Numbers 
def fib(limit): 
      
    # Initialize first two Fibonacci Numbers  
    a, b = 0, 1
  
    # One by one yield next Fibonacci Number 
    while a < limit: 
        yield a 
        a, b = b, a + b 
  
# Create a generator object 
x = fib(5) 
  
# Iterating over the generator object using next 
print(x.__next__()) --> 0
print(x.__next__()) --> 1
print(x.__next__()) --> 1
print(x.__next__()) --> 2

  
# Iterating over the generator object using for 
# in loop. 
print("\nUsing for in loop") 
for i in fib(5):  
    print(i) 



#os.walk is a generator, it searches files from a root dir mentioned to downstream/upstream recursively
# List all emp3 files under current dir structure
import os

root = "music"

for path, subdir, files in os.walk(root,topdown=True):
    if files:
        first_split = os.path.split(path)
        print("{0}".format(first_split[0]))
        for f in files:
            cleaned_name = f[:-5].split(" - ")[1]
            print(cleaned_name)

# Generators using generators:
# find all the music files by a particular artist

import os
import fnmatch


def find_album(root, artist_name):
    for path,directories,files in os.walk(root, topdown=True):
        for artist in fnmatch.filter(directories, artist_name): # fnmatch is for searching based on filename pattern
            subdir = os.path.join(path,artist)
            for artist_path, albums, _ in os.walk(subdir):
                for album in albums:
                    yield os.path.join(artist_path, album), album # generating tuple of path & album name


def find_songs(albums):
    for album in albums:
        for song in os.listdir(album[0]): # list dir as we already know about dir, do not need to walk
            yield song[:-5].split(" - ")[1]


album_list = find_album("music", "Bon Jovi")

song_list = find_songs(album_list)

for s in song_list:
    print(s)

###  fnmatch.filter can take wild card  

### Generator Expression: for artist in (d for d in directories if fnmatch.fnmatch(d.upper(), caps_name))  


difference between Iterators and Generators in python.

    In creating a python generator, we use a function. But in creating an iterator in python, we use the iter() and next() functions.
    A generator in python makes use of the ‘yield’ keyword. A python iterator doesn’t.
    Python generator saves the states of the local variables every time ‘yield’ pauses the loop in python. An iterator does not make use of local variables, all it needs is iterable to iterate on.
    A generator may have any number of ‘yield’ statements.

Generator in python is a subclass of Iterator. To prove this, we use the issubclass() function.

>>> import collections,types
>>> issubclass(types.GeneratorType,collections.Iterator)

True

---------------------------------------------
#    Decorators:
-------------------------

Decorators are a way to add additinal functionalities for a function.
They represent a higher order function, that takes another function as an argument,
define a wrapper function within decorator function - where input_function is called with additinal functionalities.
and returns the wrapper function.

In below example we have created a performance decorator, (marked by @performance) in the back end , it actually does below:
@performance
def long_time ==>

a = performance(long_time) # this call returns a function 
a() # we are calling the function

#performance decorator.

from time import time
def performance(fn):
  def wrapper(*args, **kwargs):
    t1 = time()
    result = fn(*args, **kwargs)
    t2 = time()
    print(f'took {t2-t1}')
    return result
  return wrapper

@performance
def long_time():
    for i in range(10000):
        i*5

long_time(abc) Is actually calling
v = performance(long_time)  <-performance(long_time) is returning the wrapper function to be called next with supplied parameters
v(abc)



LAMBDA function:

# The lambda fn is used for declaring "ONE_TIME USE", small, anonymous functions.
Since we will use such functions only once, we do not need any name for them.

functions with action - 1 line - can be converted to lambda functions.
lambda parameter: action(parameter)


Q. Sort a list of tuples based on 2nd key?
my_list_2 = [(0,2),(4,3),(9, 9),(10,-1)]

my_list_2 = [(0,2),(4,3),(9, 9),(10,-1)]
print(sorted(my_list_2)) # it is sorting based on 1st value from tuple

print(sorted(my_list_2,key= lambda t:t[1]))
# sorted() has an optional argument which accepts key column
# to pass the 2nd field of tuple as key we can use lambda exp


>>> add = lambda x, y: x + y
>>> add(5, 3)
8

# You could declare the same add()
# function with the def keyword:

>>> def add(x, y):
...     return x + y
>>> add(5, 3)
8

# So what's the big fuss about?
# Lambdas are *function expressions*:
>>> (lambda x, y: x + y)(5, 3)
8

# • Lambda functions are single-expression
# functions that are not necessarily bound
# to a name (they can be anonymous).

# • Lambda functions can't use regular
# Python statements and always include an
# implicit `return` statement.



# comprehensions for list,set,dict:
--------------------------------------

Comprehensions are a way to quickly build list,set or dict "without using loops".

new_list = [ action(param) for param in iterable /*option if condition*/]

my_list_4 = [num**2 for num in range(0,100) if num % 2 == 0]

dict comprehension:

sample_dict = { 'a':1, 'b':2}
my_dict = {key:value**2 for key,value in sample_dict.items() if value % 2 == 0}
print(my_dict)

#####   Q. from list of items , return only duplicate items?
-----------------------------------------------------

sample_list= ['a','b','c','x','y','b','o','m','d','o']
duplicates = list(set(x for x in sample_list if sample_list.count(x) > 1))
print(duplicates)



**** list.count(item)  ==> return no of occurances of that item in list


testrange = range(1,20)

for x in testrange:
    strval = ""
    if x % 3 == 0:
        strval += "fizz"
    if x % 5 == 0:
        strval += "buzz"
    if strval == "":
        strval += x.__str__()
    print(strval)

print("_"*40 ,"List comprehension")

a = ["fizzbuzz" if x % 15 == 0 else "buzz" if x % 5 == 0 else "fizz" if x % 3 == 0 else str(x) for x in testrange]
for i in a:
    print(i)

# Named Tuple:
---------------------
special tuples with names & property names assignment facilty
https://docs.python.org/3/library/collections.html#collections.namedtuple

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
Color = namedtuple('Color', ('red', 'green', 'blue'))

p = Point(10,20)
c = Color(10,20,30)

print(p, c)
print(p._fields)
print(c._fields)

Pixel = namedtuple('Pixel', Point._fields + Color._fields)


pixel = Pixel(p.x,p.y,c.red,c.blue,c.green)
print(pixel)



# Import system:
--------------------------------------
https://docs.python.org/3/reference/import.html

A Python module is a file that has a .py extension, and a Python package is any folder that has modules inside it (or, in Python 2, a folder that contains an __init__.py file).

A package is a foler containing modules.

__name__ is a dunder method which gives us the file currenl being referenced for import /executed as __main__ .

How Imports Work ? :
abc ->(sys.modules) -> (python builtin modules) -> (sys.path directories)

But how exactly do imports work? Let’s say you import a module abc like so:import abc
1. The first thing Python will do is look up the name abc in sys.modules. This is a cache of all modules that have been previously 
imported.
2. If the name isn’t found in the module cache, Python will proceed to search through a list of built-in modules.
 These are modules that come pre-installed with Python and can be found in the Python Standard Library. 
3. If the name still isn’t found in the built-in modules, Python then searches for it in a list of directories defined by sys.path. This list usually includes the current directory, which is searched first.
4. When Python finds the module, it binds it to a name in the local scope. This means that abc is now defined and can be used in the current file without throwing a NameError.
If the name is never found, you’ll get a ModuleNotFoundError


## A pycache file is created when a module is imported inside another python file.- It is generated by Interpreter & keep all objects being reffered inside a python script.Next time run - it will load cache file (compiled version) - we can skip compilation step.

## sys.path is initialized from these locations:

The directory containing the input script (or the current directory when no file is specified).
PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).
The installation-dependent default.

## Use dir() to examine the contents of an imported module
from packA.subA import sa1
>>> dir(sa1)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'helloWorld']

by default import executes the imported file, while importing , to avoid that execution we include a section

if "__name__" == "__main__"

__name__ is a builtin attribute which stores the name of module being executed, value __main__ means part from current program
being executed, If we have a program which is importing many packages/modules, better to include __main__ section for that program part to 
be executed as main ,and code sections from imported modules will be executed only when they are asked.

importlib module - is useful to import a module -- useful to import a file directly , so that we can use functions/classes written inside file

# Global variable & nonlocal variable
----------------------------------------

# When we refer/use a variable inside a function & try to assign value, Python creates a local copy of the variable
and use it. to use the global copy we need to mark the variable global inside functions scope.

# New scopes are created in python only by class, function & module.

# LEGB - Local -> Enclosing-> Global-> Bundle - variable search precedence - 

# Nonlocal - marking a variable nonlocal means the variable has to be defined in enclosing scope.

Exercise for reference: 

The following script throws a NameError  in the last line saying that c  is not defined. 
Please fix the function so that there is no error and the last line is able to print out the value of c  (i.e. 1 ).

    def foo(): 
        c = 1 
        return c 
    foo() 
    print(c)

Answer: 

    def foo():
        global c
        c = 1 
        return c 
    foo() 
    print(c)

Explanation:

Adding global c  fixes the code. That line makes available name c  in the global namespace. 
Therefore,  print is able to access variable c .

Nonlocal variable example: -- remember - Nested function 
-----------------------------
Nonlocal variables are used in nested functions whose local scope is not defined. This means that the variable can be neither in the local nor the global scope.

Let's see an example of how a nonlocal variable is used in Python.

We use nonlocal keywords to create nonlocal variables.
Example 6: Create a nonlocal variable

def outer():
    x = "local"

    def inner():
        nonlocal x
        x = "nonlocal"
        print("inner:", x)

    inner()
    print("outer:", x)


outer()

Output

inner: nonlocal
outer: nonlocal

In the above code, there is a nested inner() function. We use nonlocal keywords to create a nonlocal variable. The inner() function is defined in the scope of another function outer().





## Find mp3 file from a root dir:
import os
import fnmatch
import id3reader_p3 as id3reader


def find_mp3file(start_dir, extension):
    for path, subdir, files in os.walk(start_dir):
        for file in fnmatch.filter(files, "*.{}".format(extension)):
            yield os.path.abspath(os.path.join(path, file))


problem_files = []


for f in find_mp3file('music', '*mp3'):
    try:
        idr3 = id3reader.Reader(f)
        if callable(idr3.get_value) and callable(idr3.get_value) and callable(idr3.get_value) \
                and callable(idr3.get_value):
            print("filename: {}".format(f))
            print("Artist: {0}\nAlbum: {1} \nTrack: {2} \nTitle: {3}\n".format(idr3.get_value('performer'),
                                                                     idr3.get_value('album'),
                  idr3.get_value('genre'), idr3.get_value('title')))
    except OSError:
        problem_files.append(f)

# Glob module:
-----------------------
glob — Unix style pathname pattern expansion
The glob module finds all the pathnames matching a specified pattern according to the rules used by the Unix shell,
glob.glob(pathname, *, recursive=False)
If recursive is true, the pattern “**” will match any files and zero or more directories, subdirectories and symbolic links to directories.
>>> glob.glob('**/*.txt', recursive=True)
['2.txt', 'sub/3.txt']

Q. Create a script that iterates through text files and checks if strings p, y, t, h, o, or n are found in the content of the text file. If any of those strings is found, append that string to a list.

    import glob
     
    letters = []
    file_list = glob.iglob("letters/*.txt")
    check = "python"
     
    for filename in file_list:
        with open(filename,"r") as file:
            letter = file.read().strip("\n")
        if letter in check:
            letters.append(letter)
     
    print(letters)

Word counter:
Create a function that takes a text file as input and returns the number of words contained in the text file. Please take into consideration that some words can be separated by a comma with no space. For example "Hi,it's me." would need to be counted as three words. For your convenience, you can use the text file in the attachment.

    import re
     
    def count_words_re(filepath):
        with open(filepath, 'r') as file:
            text = file.read()
        string_list = re.split(",| ", text)
        return len(string_list)
     
    print(count_words_re("words2.txt"))

Explanation 2:

This alternative solution uses the built-in re  module which provides regular expression matching operations. We're using the split method of that module and the expression ",| " means to split at "," or " ".Returns a list of all words. Using methods from the re  module can be more appropriate than Python built-in methods when string operations are complicated. However, for this simple scenario the re  module could be skipped.


collections module: OrderedDict objects
----------------------------------------

Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations


# enumarate:
--------------

Enumerate() in Python

A lot of times when dealing with iterators, we also get a need to keep a count of iterations. Python eases the programmers’ task by providing a built-in function enumerate() for this task.
Enumerate() method adds a counter to an iterable and returns it in a form of enumerate object. This enumerate object can then be used directly in for loops or be converted into a list of tuples using list() method.

l1 = ["eat","sleep","repeat"] 
s1 = "geek"
obj1 = enumerate(l1) 
obj2 = enumerate(s1) 
print list(enumerate(l1)) 
[(0, 'eat'), (1, 'sleep'), (2, 'repeat')]

print list(enumerate(s1,2)) 
[(2, 'g'), (3, 'e'), (4, 'e'), (5, 'k')]


# Import statements first look for a local file in the current directory (e.g. requests.py). 
If there is such file it imports that file, and not the actual module. 


# https://docs.python.org/3.8/tutorial/stdlib.html

#Downloading file content
----------------------------

https://realpython.com/python-requests/

requests package - The requests library is the de facto standard for making HTTP requests in Python

There are a number of modules for accessing the internet and processing internet protocols. 
Two of the simplest are urllib.request for retrieving data from URLs and smtplib for sending mail:

from urllib.request import urlopen

with urlopen("http://www.pythonhow.com/data/universe.txt") as response_data:
    for line in response_data:
        line = line.decode("utf-8") # Decoding the binary data to text.
        print(line)

 # Request module can work as well easily: Count no of a s in the data downloaded from url:
 ------------------------------------------------------------------------------------------

import requests
response = requests.get("http://www.pythonhow.com/data/universe.txt", headers={'user-agent': 'customUserAgent'})
text = response.text
cnt = text.count("a")
print(" No of a in text: {}".format(str(cnt)))

# Webbrowser module to open a new page:
----------------------------------------
# https://www.google.com/search?q=tomato+rice

import webbrowser

inp = input("Enter input string to search: ")
url = "https://www.google.com/search?q="+inp
webbrowser.open_new(url)


# Download file from url, save to a file  & plot data
-------------------------------------------------------

Has been done using pandas, pylab plot

import pandas
from matplotlib import pyplot

data = pandas.read_csv("http://www.pythonhow.com/data/sampledata.txt")
data.plot(x="x", y="y", kind="scatter")
pyplot.show()


# Datetime module - strftime() and strptime() Behavior
--------------------------------------------------------

date, datetime, and time objects all support a strftime(format) method, to create a string representing 
the time under the control of an explicit format string.

Conversely, the datetime.strptime() class method creates a datetime object from a string representing a date and time and a corresponding format string

See this for format usage: https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior


# password checker - password having atleast one uppercase, number & minium length :

soln: using list comprehension & any() function:


# any & all function : builtin function:
-------------------------------------------

all(*args, **kwargs): # real signature unknown

    Return True if bool(x) is True for all values x in the iterable.
    If the iterable is empty, -----v imp --->>>>>>>  return True.
    """
    pass

any(*args, **kwargs): # real signature unknown
    """
    Return True if bool(x) is True for any x in the iterable.
    If the iterable is empty, return False.

# File search - glob.glob & glob.glob1
--------------------------------------

# Please download the attached ZIP file and extract its files in a folder. 
Then, write a script that counts and prints out the number of .py files in that folder.
-----------------------------------------------

Answer: 

    import glob
     
    file_list=glob.glob1("files","*.py")
    print(len(file_list))

Explanation:

We're using glob  which is a standard Python library that finds pathnames matching a specified pattern. From glob  we're using glob1  which takes a directory name as first argument and a pattern which in our case is *.py  which returns all the files starting with whatever and ending with .py in the files  directory.




# Please download the attached ZIP file. Inside the ZIP file there's a directory named subdirs. 
That directory contains other directories inside. Please write a script that counts the number of .py 
files contained inside subdirs and all its sub-directories.
------------------------------------------------

Answer: 

    import glob
     
    file_list = glob.glob("subdirs/**/*.py", recursive=True)
    print(len(file_list))

Explanation:

We're using glob.glob  in contrast to glob.glob1 , gets a pathname pattern and a recursive  argument which indicates whether you want to search sub-directories or not.


# Flask - module is used to create webapplication, if we want to create a web page which will take user_texts & keep them in a file , that can 
be done using flask, erercise-99 & 100 of 100-python exercise is using this.


# ------------------------------------------





2. MultiThreading
3. Multiprocessing

---------------------------------------------
# Testing in python

We create a test file for every .py file we create 


import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()

A testcase is created by subclassing unittest.TestCase. The three individual tests are defined with methods whose names start with the letters test. This naming convention informs the test runner about which methods represent tests.

The crux of each test is a call to assertEqual() to check for an expected result; assertTrue() or assertFalse() to verify a condition; or assertRaises() to verify that a specific exception gets raised. These methods are used instead of the assert statement so the test runner can accumulate all test results and produce a report.

The setUp() and tearDown() methods allow you to define instructions that will be executed before and after each test method.

unittest.main() -> A command-line program that loads a set of tests from module and runs them; this is primarily for making test modules conveniently executable. The simplest use for this function is to include the following line at the end of a test script:


import sys

sys.argv -> helps to take paramaters passed to a program
1st index argv[0] is always file name.

pip install / upgrade - pip is used to share /install a package developed by 3rd party developers in your code.

how to have multi version of same package to work with - answer -virtual environment
pipenv - to keep package version dependencies

3rd party packages are available in PyPi


## Difference between a package & a module
A package is a collection of Python modules: while a module is a single Python file, a package is a directory of Python modules containing an additional __init__.py file, to distinguish a package from a directory that just happens to contain a bunch of Python scripts.


# useful modules:
1. collections module
--> Counter object - returns dict of each item with no of occurances - {'a':1, 'b':2, 'c':1} for a string of babc
--> defaultDict - defaultDict(function_1, {'a':1, 'b':2 })  => defaultDict needs 1st arg to be callable, so we can use a lambda function
as well, lambda : 'does not exist'
so with 
sample_dict = defaultDict(lambda : 'does not exist', {'a':1, 'b':2 })
print(sample_dict['c']) will return 'does not exist'

--> OrderedDict - maintains the order

--> queue,deque

2. datetime module 
datetime.date.today() - gives todays date
3. time module
from time import time

4. array module- from array import array
need to mention datatype for computer to optimize memory
arr = array('i',[1,2,3]) 'i' stands for integer

# debugging code:
use of python debugger,

import pdb

use pdb.set_trace()
--interactive command prompt, step, continue


----------------------------------------------
2.2 Garbage generation/collection





---------------------------------------------
Functinal programming:

unlike OOP - functional prog seperates data from functions, We work with "pure functions" - functions that takes input, but does not have 
any side effect.

# map,filter,zip & reduce
map(function_name, iterable) --> iterable (immutable) 

def multiply_by_2(i):
    return i*2

def only_odd(i):
    return i%2 == 1

print(list(map(multiply_by_2, [1,2,3]))) 
print(list(filter(only_odd, [1,2,3]))) 

print(list(zip(mylist, your_list))) - actual function - zip(iterable_1,iterable_2)
an example like zip(list,tuple) is also possible

def accumulator(acc,item):
    return acc + item

reduce(accumulator, [1,2,3], 0) ==> 0 is initial value, accumulator is the func name.Initially 0 will be assigned to acc inside accumulator
& 1 from list to item value

my_numbers = [5,4,3,2,1]
scores = [73, 20, 65, 19, 76, 100, 88]
def red_val(acc, i):
  return acc + i

reduce(red_val, (my_numbers + scores), 0)





---------------------------------------------
Pytest :  
A Test runner - The test runner is a special application designed for running tests, checking the output, and giving you tools for debugging and diagnosing tests and applications.

Create a new project folder and, inside that, create a new folder called my_sum. Inside my_sum, 
create an empty file called __init__.py. Creating the __init__.py file means that the my_sum folder can be imported as a module from the parent directory.
It is convention to ensure each file starts with test_ so all test runners will assume that Python file contains tests to be executed.

# Note: What if your application is a single script?
You can import any attributes of the script, such as classes, functions, and variables by using the built-in __import__() function. Instead of

from my_sum import sum, you can write the following:
target = __import__("my_sum.py")
sum = target.sum
The benefit of using __import__() is that you don’t have to turn your project folder into a package, and you can specify the file name


Instead of providing the name of a module containing tests, you can request an auto-discovery using the following:

$ python -m unittest discover

This will search the current directory for any files named test*.py and attempt to test them.

Once you have multiple test files, as long as you follow the test*.py naming pattern, you can provide the name of the directory instead by using the -s flag and the name of the directory:

$ python -m unittest discover -s tests
unittest will run all tests in a single test plan and give you the results.
The specify source directory flag, -s, can be added to unittest discover with the path containing the tests:

$ python -m unittest discover -s tests/integration


three basic steps of every test:

    Create your inputs
    Execute the code, capturing the output
    Compare the output with an expected result

It’s not always as easy as creating a static value for the input like a string or a number. Sometimes, your application will require an instance of a class or a context. What do you do then?

The data that you create as an input is known as a fixture. It’s common practice to create fixtures and reuse them.

If you’re running the same test and passing different values each time and expecting the same result, this is known as parameterization.

Handling Expected Failures
Earlier, when you made a list of scenarios to test sum(), a question came up: What happens when you provide it with a bad value, such as a single integer or a string?
In this case, you would expect sum() to throw an error. When it does throw an error, that would cause the test to fail.
There’s a special way to handle expected errors. You can use .assertRaises() as a context-manager, then inside the with block execute the test steps:


    def test_bad_type(self):
        data = "banana"
        with self.assertRaises(TypeError):
            result = sum(data)


To execute the tests from a specific file, use the following syntax − pytest <filename> -v
Pytest provides two ways to run the subset of the test suite.

1. Select tests to run based on substring matching of test names.
pytest -k <substring> -v 
-k <substring> represents the substring to search for in the test names.

2. Select tests groups to run based on the markers applied.
Pytest allows us to use markers on test functions.Pytest provides many inbuilt markers such as
xfail
skip
parametrize.
 Apart from that, users can create their own marker names. Markers are applied on the tests using the syntax given below −
import pytest
@pytest.mark.<markername>

To run the marked tests, we can use the following syntax − pytest -m <markername> -v

import pytest
@pytest.mark.great
def test_greater():
   num = 100
   assert num > 100

pytest -m great -v


-----------------
Pytest fixtures
-----------------
Fixtures are functions, which will run before each test function to which it is applied.

Fixtures are used to feed some data to the tests such as database connections, URLs to test and some sort of input data. Therefore, instead of running the same code for every test, we can attach fixture function to the tests and it will run and return the data to the test before executing each test.

A function is marked as a fixture by − @pytest.fixture
A test function can use a fixture by mentioning the fixture name as an input parameter.

import pytest

@pytest.fixture
def input_value():
   input = 39
   return input

def test_divisible_by_3(input_value):
   assert input_value % 3 == 0

def test_divisible_by_6(input_value):
   assert input_value % 6 == 0

Pytest while the test is getting executed, will see the fixture name as input parameter. It then executes the fixture function and the returned value is stored to the input parameter, which can be used by the test.

Limitation of fixture:
A fixture function defined inside a test file has a scope within the test file only. 
We cannot use that fixture in another test file. To make a fixture available to multiple test files, we have to define the fixture function in a file called conftest.py.

Conftest.py - 
We can define the fixture functions in Conftest.py file to make them accessible across multiple test files.
The tests in a test file will look for fixture in the same file. As the fixture is not found in the test file, it will check for fixture in conftest.py file. On finding it, the fixture method is invoked and the result is returned to the input argument of the test.


pytest markers: 

Parameterize - @pytest.mark.parametrize
Parameterizing is done to run the test fn against multiple sets of inputs.

import pytest

@pytest.mark.parametrize("num, output",[(1,11),(2,22),(3,35),(4,44)])
def test_multiplication_11(num, output):
   assert 11*num == output

Skip and Xfail tests in Pytest:

When to use?
1. A test is not relevant for some time due to some reasons.
2. A new feature is being implemented and we already added a test for that feature.
In these situations, we have the option to xfail the test or skip the tests.

Pytest will execute the xfailed test, but it will not be considered as part failed or passed tests. Details of these tests will not be printed even if the test fails (remember pytest usually prints the failed test details). We can xfail tests using the following marker −

@pytest.mark.xfail

Skipping a test means that the test will not be executed. We can skip tests using the following marker −

@pytest.mark.skip


Stop Test Suite after N no of failures-
if we want to stop the execution of test suite soon after n number of test fails. This can be done in pytest using maxfail.
The syntax to stop the execution of test suite soon after n number of test fails is as follows −

pytest --maxfail = <num>
eg:  pytest test_failure.py -v --maxfail 1

MonkeyPatching - to Guard Access
--------------------------------
Another interesting use case for fixtures is in guarding access to resources. Imagine that you’ve written a test suite for code that deals with API calls. You want to ensure that the test suite doesn’t make any real network calls, even if a test accidentally executes the real network call code. pytest provides a monkeypatch fixture to replace values and behaviors, which you can use to great effect:

# conftest.py

import pytest
import requests

@pytest.fixture(autouse=True)
def disable_network_calls(monkeypatch):
    def stunted_get():
        raise RuntimeError("Network access not allowed during testing!")
    monkeypatch.setattr(requests, "get", lambda *args, **kwargs: stunted_get())

By placing disable_network_calls() in conftest.py and adding the autouse=True option, you ensure that network calls will be disabled in every test across the suite. Any test that executes code calling requests.get() will raise a RuntimeError indicating that an unexpected network call would have occurred.


---------------------------------------------

Difference between a class method & static method?
--------------------------------------------------

A class method is bound to a class rather than its object.Using class method doesn't require creation of a class instance, much like staticmethod.

The difference between a static method and a class method is:

    Static method knows nothing about the class and just deals with the parameters
    Class method works with the class since its parameter is always the class itself.

Eg:
class Person:
    age = 25

    def printAge(cls):
        print('The age is:', cls.age)

Factory methods
---------------------------------------------
Factory methods are those methods that return a class object like constructor but for different use case.
Python uses cls option instead of self, for this purpose
Can be implemented by classmethod.

from datetime import date

# random Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def fromBirthYear(cls, name, birthYear):
        return cls(name, date.today().year - birthYear)

    def display(self):
        print(self.name + "'s age is: " + str(self.age))

person = Person('Adam', 19)
person.display()

person1 = Person.fromBirthYear('John',  1985)
person1.display()



-------------------------------------

MultiProcessing(Parallelism) & MultiThreading(Concurrency):


# One process can spawn multiple threads, all of which can work on a single core of processor.

In multiprocessing, multiple processes are created, each of which work on individual cores.
 Rule of thumb, IO intensive actions works better with MultiThreading, CPU intensive 
actions/functions/scripts work better with multiprocessing.


Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn't necessarily mean they'll ever both be running at the same instant. For example, multitasking on a single-core machine.

Parallelism is when tasks literally run at the same time, e.g., on a multicore processor.


Modern ways of creating processes & threads is to use ProcessPoolExecutor & ThreadPoolExecutor() from concurrent.futures module





---------------------------
Python | Method Overloading

Like other languages (for example, method overloading in C++) do, python does not support method overloading by default. But there are different ways to achieve method overloading in Python. 

The problem with method overloading in Python is that we may overload the methods but can only use the latest defined method

https://www.geeksforgeeks.org/python-method-overloading/

Method overriding 
is an ability of any object-oriented programming language that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. When a method in a subclass has the same name, same parameters or signature and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class.

overriding-in-python

The version of a method that is executed will be determined by the object that is used to invoke it. If an object of a parent class is used to invoke the method, then the version in the parent class will be executed, but if an object of the subclass is used to invoke the method, then the version in the child class will be executed. In other words, it is the type of the object being referred to (not the type of the reference variable) that determines which version of an overridden method will be executed.

https://www.geeksforgeeks.org/method-overriding-in-python/



https://myZTMtest.com

Consumer API keys
API key:         ytX3FwXwrPZAks2ylWCKeaL38
API secret key:  W3TyuokgT9J1e59qEIQVCODESZAc3KjBtTI4LaQpMYOE3G4zvs

access token :       1264572549343543296-yjOL2zqQUpEnxw5oDmVglHQBsH4i7Z
access token secret: 3HWamtkwULy5NOHk0Ao7oNF3v0gCIG6uLIkifcANUGBhO




fabric library - python



# python subprocess module to run any system command - enhanced version of system module

--------------
Git:
--------------
working dir<---(git add/rm)--> staging area -->(git commit)-->local repository <--(git clone)--> remote repository

git rm --cached filename
git log
git status
git checout - set the the head pointer to last commit point
git log --oneline
git revert vs git reset = > revert sets pointer permanently one commit back, 
git reset has -soft,-mixed, - hard => hard one will permanentky set head pomter to the id but remove all earlier ids and changes contents 
git ignore - helps to untrack files permanently as long as they are in the file => create a .gitignore file
git rm -r --cached . =. REMOVES ALL CACHED FILES
git checkout -b "Dev" => will create a new branch called Dev from master branch
git branch <branch_name> craetes new branch 
git branch -a => lists all the branches
git checkout master => switches to master 

fork - create a copy of the repository and put it in your account

# connecting a local git repository with remote GitHub repo - it is done via "origin" ->
git remote add origin https://github.groupondev.com/grpn-data-pipelines/hly_glive_purchase.git
Test it via :
git remote -v

git pull/push -> 

git pull origin master -> fetches all commites from githib from master branch
git push origin master -> 
git pull origin PRE-164 --> pulls specific branch

Usual process for projects - pull problematic code to local repo-> create a new branch-> fix it-> puch it back to repository-> delete branch
git pull
git checkout -b edw_jira    ==> branch name edw_jira
fix issue 
git add .
git commit -m "fixed issue"
git checkout master
git merge edw_jira => merges code in master branch of local repository
git push origin master => push to remote
git push origin edw_jira => sending error branch to remote as well

To delete a remote branch:
git push origin --delete edw_jira

git clone:
git clone git@github.groupondev.com:grpn-data-pipelines/hly_glive_purchase.git

git remote remove origin
git remote add origin git@github.groupondev.com:grpn-data-pipelines/hly_glive_purchase.git
git push -u origin master

git rebase: (DO not do rebase into public repo)

master : m1 -> m2 -> m3
feature:       m2 -> f1 -> f2

we are in feature : git rebase feature will put m3 into feature branch,
master : m1 -> m2 -> m3
feature:             m3 -> f1 -> f2

git merge -squash feature:
it will take all commits from feature and put it as a single commit in master:

master : m1 -> m2 -> m3
feature:       m2 -> f1 -> f2

after we do git merge --squash feature

master : m1 -> m2 -> m3 -> [f1 + f2 squashed into one commit]


(base) C02W213DHTD7:hly_glive_purchase smukherjee$ git pull origin PRE-164
From github.groupondev.com:grpn-data-pipelines/hly_glive_purchase
 * branch            PRE-164    -> FETCH_HEAD
Updating 9cef3c7..0dba154
Fast-forward
 .gitignore                                            | 127 +++++++++++++++++++++++++++
 Makefile                                              |   8 +-
 Pipfile                                               |   5 +-
 Pipfile.lock                                          | 207 ++++++++++++++++++++++++++++++++++++++++++++
 README.md                                             |  71 +++++++++++++++
 configs/cfg_prod_groupondw_glive_purchase.yml         |   4 +
 configs/cfg_prod_groupondw_glive_purchase_history.yml |   4 +
 configs/glive_purchase_config.ini                     |  16 ++++
 dependencies/sample_spark_driver.py                   | 153 +++++++++++++++++++++++++++++++++
 dependencies/spark_driver.py                          | 134 +++++++++++++++++++++++++++++
 generic/functions.py                                  |  20 +++++
 jobs/complete_load_td_inc_table.py                    | 362 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 jobs/distcp_pit_gdoop.sh                              |  74 ++++++++++++++++
 jobs/load_td_inc_table.py                             |  55 ++++++++++++
 jobs/td_gdoop/extract_td_gdoop.yml                    |  48 +++++++++++
 tests/conftest.py                                     |   1 +
 tests/test_sample_job/test_sample_job.py              |   2 +
 17 files changed, 1287 insertions(+), 4 deletions(-)
 create mode 100644 Pipfile.lock
 create mode 100644 configs/cfg_prod_groupondw_glive_purchase.yml
 create mode 100644 configs/cfg_prod_groupondw_glive_purchase_history.yml
 create mode 100644 configs/glive_purchase_config.ini
 create mode 100644 dependencies/sample_spark_driver.py
 create mode 100644 dependencies/spark_driver.py
 create mode 100644 generic/functions.py
 create mode 100644 jobs/complete_load_td_inc_table.py
 create mode 100755 jobs/distcp_pit_gdoop.sh
 create mode 100644 jobs/load_td_inc_table.py
 create mode 100755 jobs/td_gdoop/extract_td_gdoop.yml

Git GUI : source tree


---------------

Hi All
11:14
HR had asked us to choose the best job profile for our team and we landed up in Big Data Engg which is similar to SDE in comp level also.
11:14
so we have to go through the process
11:14

Interview topics:
1.5 hour: Programming
Language proficiency evaluation: Scala/ Java/ Python or any language Engineer claims proficiency in
Ability to test own code - Scala/ Java/ Python test (for unit testing)

1.5 hour: Concepts
Data Structures.
Runtime and memory efficiency (O notation).
OOP concepts.
Recursion
Variable scope.
Garbage collection
System Architecture - 
https://swi.cs.vsb.cz/RUPLarge/core.base_rup/guidances/concepts/system_architecture_5F3B1E17.html
https://towardsdatascience.com/10-common-software-architectural-patterns-in-a-nutshell-a0b47a1e9013

Code Deployment
Automation
Programming models - 
https://softwareengineering.stackexchange.com/questions/365755/what-is-a-programming-model
https://www.dauniv.ac.in/public/frontassets/coursematerial/embeddedsystems/Chap_8Lesson1Emsys3EProgModels.pdf
Design Patterns - ?



